import Foundation

/// Generates Project.swift content for Tuist
struct ProjectWriter {

    /// Resource patterns that match SPM's automatic resource detection
    private static let spmResourcePatterns = [
        "**/*.xcassets",
        "**/*.xib",
        "**/*.storyboard",
        "**/*.xcdatamodeld",
        "**/*.xcmappingmodel",
        "**/*.lproj/**",
        "**/*.metal",
        "Resources/**"  // Fallback for explicit resources folder
    ]

    /// Generate Project.swift content for a Tuist project
    func generate(project: TuistProject) -> String {
        let targetCodes = project.targets.map { generateTarget($0) }

        return """
        // Generated by PackageToTuistProject
        import ProjectDescription

        let project = Project(
            name: "\(project.name)",
            options: .options(
                disableSynthesizedResourceAccessors: true
            ),
            targets: [
        \(targetCodes.joined(separator: ",\n"))
            ]
        )
        """
    }

    private func generateTarget(_ target: TuistTarget) -> String {
        // Collect all arguments as (label, value) pairs
        var arguments: [(String, String)] = []

        arguments.append(("name", "\"\(target.name)\""))
        arguments.append(("destinations", target.destinations))
        arguments.append(("product", target.product.swiftCode))
        arguments.append(("bundleId", "\"\(target.bundleId)\""))

        if let deploymentTargets = target.deploymentTargets {
            arguments.append(("deploymentTargets", deploymentTargets))
        }

        arguments.append(("sources", "[\"\(target.sourcesPath)/**\"]"))
        arguments.append(("resources", generateResourcesGlobs(for: target.sourcesPath)))

        if !target.dependencies.isEmpty {
            let depsCode = target.dependencies.map { $0.swiftCode }
            arguments.append(("dependencies", "[\n                \(depsCode.joined(separator: ",\n                "))\n            ]"))
        }

        // Add settings with -package-name flag for package access level support
        // and STRING_CATALOG_GENERATE_SYMBOLS which is the default for Swift packages
        var settingsPairs: [String] = [
            "\"OTHER_SWIFT_FLAGS\": [\"-package-name\", \"\(target.packageName)\"]",
            "\"STRING_CATALOG_GENERATE_SYMBOLS\": \"YES\"",
            "\"SWIFT_PACKAGE_NAME\": \"\(target.packageName)\"",
            "\"SWIFT_ACTIVE_COMPILATION_CONDITIONS\": \"$(inherited) SWIFT_PACKAGE\""
        ]
        if target.needsTestingSearchPaths {
            settingsPairs.append("\"ENABLE_TESTING_SEARCH_PATHS\": \"YES\"")
        }
        arguments.append(("settings", ".settings(base: [\(settingsPairs.joined(separator: ", "))])"))

        // Single place where commas are added - join all arguments
        let argumentsCode = arguments
            .map { "            \($0.0): \($0.1)" }
            .joined(separator: ",\n")

        return """
                .target(
        \(argumentsCode)
                )
        """
    }

    private func generateResourcesGlobs(for sourcesPath: String) -> String {
        let patterns = Self.spmResourcePatterns.map { "\"\(sourcesPath)/\($0)\"" }
        return "[\(patterns.joined(separator: ", "))]"
    }

    /// Write Project.swift to disk
    func write(project: TuistProject, dryRun: Bool, verbose: Bool) throws {
        let content = generate(project: project)
        let projectDir = URL(fileURLWithPath: project.path)
        let outputPath = projectDir.appendingPathComponent("Project.swift")

        if dryRun {
            print("\n--- Would write to: \(outputPath.path) ---")
            print(content)
            print("--- End ---\n")
        } else {
            try content.write(to: outputPath, atomically: true, encoding: .utf8)
            if verbose {
                print("Wrote: \(outputPath.path)")
            }
        }
    }
}
