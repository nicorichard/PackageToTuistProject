import Foundation

/// Generates Project.swift content for Tuist
struct ProjectWriter {

    /// Resource patterns that match SPM's automatic resource detection
    private static let spmResourcePatterns = [
        "**/*.xcassets",
        "**/*.xib",
        "**/*.storyboard",
        "**/*.xcdatamodeld",
        "**/*.xcmappingmodel",
        "**/*.lproj/**",
        "**/*.strings",
        "**/*.stringsdict",
        "**/*.metal",
        "**/Resources/**"  // Fallback for explicit resources folder
    ]

    /// Generate Project.swift content for a Tuist project
    func generate(project: TuistProject) -> String {
        let targetCodes = project.targets.map { generateTarget($0) }

        return """
        // swiftlint:disable:this file_name
        // swiftlint:disable all
        // swift-format-ignore-file
        // swiftformat:disable all
        //
        // Generated by PackageToTuistProject
        import ProjectDescription

        let project = Project(
            name: "\(project.name)",
            options: .options(
                disableSynthesizedResourceAccessors: true
            ),
            targets: [
        \(targetCodes.joined(separator: ",\n"))
            ]
        )

        // swiftformat:enable all
        // swiftlint:enable all

        """
    }

    private func generateTarget(_ target: TuistTarget) -> String {
        // Collect all arguments as (label, value) pairs
        var arguments: [(String, String)] = []

        arguments.append(("name", "\"\(target.name)\""))
        arguments.append(("destinations", target.destinations))
        arguments.append(("product", target.product.swiftCode))
        arguments.append(("bundleId", "\"\(target.bundleId)\""))

        if let deploymentTargets = target.deploymentTargets {
            arguments.append(("deploymentTargets", deploymentTargets))
        }

        arguments.append(("sources", "[\"\(target.sourcesPath)/**\"]"))
        arguments.append(("resources", generateResourcesGlobs(for: target.sourcesPath)))

        if !target.dependencies.isEmpty {
            let depsCode = target.dependencies.map { $0.swiftCode }.joined(separator: ",\n")
            arguments.append(("dependencies", """
                [
                    \(indented: depsCode)
                ]
                """))
        }

        // Add settings with -package-name flag for package access level support
        // and STRING_CATALOG_GENERATE_SYMBOLS which is the default for Swift packages
        let swiftFlags = generateSwiftFlags(packageName: target.packageName, swiftSettings: target.swiftSettings)
        var settingsPairs: [String] = [
            "\"OTHER_SWIFT_FLAGS\": \(swiftFlags)",
            "\"STRING_CATALOG_GENERATE_SYMBOLS\": \"YES\"",
            "\"SWIFT_PACKAGE_NAME\": \"\(target.packageName)\"",
            "\"SWIFT_ACTIVE_COMPILATION_CONDITIONS\": \"$(inherited) SWIFT_PACKAGE\""
        ]
        if target.needsTestingSearchPaths {
            settingsPairs.append("\"ENABLE_TESTING_SEARCH_PATHS\": \"YES\"")
        }
        let settingsCode = settingsPairs.joined(separator: ",\n")
        arguments.append(("settings", """
            .settings(base: [
                \(indented: settingsCode)
            ])
            """))

        // Single place where commas are added - join all arguments
        // Indent multi-line values so all lines align properly
        let baseIndent = "            " // 12 spaces for argument level
        let argumentsCode = arguments
            .map { label, value in
                let indentedValue = value.split(separator: "\n", omittingEmptySubsequences: false)
                    .enumerated()
                    .map { index, line in
                        index == 0 ? String(line) : baseIndent + String(line)
                    }
                    .joined(separator: "\n")
                return "\(baseIndent)\(label): \(indentedValue)"
            }
            .joined(separator: ",\n")

        return """
                .target(
        \(argumentsCode)
                )
        """
    }

    private func generateResourcesGlobs(for sourcesPath: String) -> String {
        let patterns = Self.spmResourcePatterns.map { "\"\(sourcesPath)/\($0)\"" }.joined(separator: ",\n")
        return """
            [
                \(indented: patterns)
            ]
            """
    }

    /// Generate OTHER_SWIFT_FLAGS array including package name and swift settings
    private func generateSwiftFlags(packageName: String, swiftSettings: [SwiftSetting]?) -> String {
        var flags: [String] = ["-package-name", packageName]

        if let settings = swiftSettings {
            for setting in settings {
                // Note: Conditions (debug/release, platform) are ignored for Phase 1
                // Settings are applied unconditionally
                switch setting.kind {
                case .enableUpcomingFeature(let feature):
                    flags.append("-enable-upcoming-feature")
                    flags.append(feature)
                case .enableExperimentalFeature(let feature):
                    flags.append("-enable-experimental-feature")
                    flags.append(feature)
                case .define(let macro):
                    flags.append("-D")
                    flags.append(macro)
                case .unsafeFlags(let customFlags):
                    flags.append(contentsOf: customFlags)
                }
            }
        }

        let quotedFlags = flags.map { "\"\($0)\"" }.joined(separator: ",\n")
        return """
            [
                \(indented: quotedFlags)
            ]
            """
    }

    /// Write Project.swift to disk
    func write(project: TuistProject, dryRun: Bool, verbose: Bool) throws {
        let content = generate(project: project)
        let projectDir = URL(fileURLWithPath: project.path)
        let outputPath = projectDir.appendingPathComponent("Project.swift")

        if dryRun {
            print("\n--- Would write to: \(outputPath.path) ---")
            print(content)
            print("--- End ---\n")
        } else {
            try content.write(to: outputPath, atomically: true, encoding: .utf8)
            if verbose {
                print("Wrote: \(outputPath.path)")
            }
        }
    }
}
